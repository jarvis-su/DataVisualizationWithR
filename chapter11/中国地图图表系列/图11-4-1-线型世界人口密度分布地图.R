

library(graphics)
library(tcltk)
library(pracma)

# Load the data generated by 01GenerateData.R
plot.data <- read.csv("WorldPopulation.csv", header=TRUE, stringsAsFactors=FALSE)

# Add padding above/below where there was data

# On top
top.padding <- 1:1
for (i in top.padding) {
  plot.data <- cbind(0, plot.data)
}
# On bottom
bottom.padding <- 1:1
for (i in bottom.padding) {
  plot.data <- cbind(plot.data, 0)
}

# On left
zero.row <- vector(mode="integer", length=dim(plot.data)[1])

left.padding <- 1:10
for (i in left.padding) {
  plot.data <- rbind(zero.row, plot.data)
}

# On right
right.padding <- 1:10
for (i in left.padding) {
  plot.data <- rbind(plot.data, zero.row)
}


max <- max(plot.data) # Max value in the data, used for scaling
plottingHeight <- 1000 # Arbitrary number that provides the graph's height
scaleFactor <- 300 # Discovered through trial and error to keep the graph in the boundaries
gap <- plottingHeight / length(plot.data) # Space between lines

plot.width = 25
plot.height = 15
#svg(filename = "./CanadaSGBigPeaks2.svg", pointsize=12, width=plot.width, height=plot.height)

# Create a blank plot
yVals <- as.vector(plot.data[[1]] / max * scaleFactor)
plot(0, 0, xlim=c(0, length(yVals)), ylim=c(0,1100), type="n", las=1, xlab=NA, ylab=NA, bty="n", axes=FALSE)

plotting.threshold <- 0.1

plot.length = length(plot.data)

plot.data2<-plot.data
plot.data3<-data.frame(x=0,y=0,height=0,group=0)
groupid<-1
# Plot each line
for (i in 1:plot.length) {
  # Grabs a row of data
  yVals <- as.vector(plot.data[[i]] / max * scaleFactor)
  xVals <- c(0:(length(yVals) - 1))
  yVals.smooth =  savgol(yVals, 3, forder=4)
  
  plot.data2[[i]]<-yVals.smooth
  
  #polygon(xVals, yVals.smooth + plottingHeight, border = NA, col = "#ffffff")
  #lines(xVals, yVals.smooth + plottingHeight, col="#8C8C8C", lwd=0.5)
  
  #Plot the peaks with a darker line.
  j <- 2 # Skip padding

  while (j <= (length(yVals.smooth) - 2)) {

    if ((yVals.smooth[j]) > plotting.threshold | (yVals.smooth[j+1]) > plotting.threshold) {
     # segments(xVals[j], yVals.smooth[j] + plottingHeight, xVals[j+1], yVals.smooth[j+1] + plottingHeight, col="#000000", lwd=1.5)
      
      plot.data3<-rbind(plot.data3,c(xVals[j],i,yVals.smooth[j],groupid))
    } else { 
      
      groupid<-groupid+1
      
    } # Do nothing

    j <- j + 1

  }
  plottingHeight <- plottingHeight - gap
  

}

#dev.off()

library(reshape2)
colnames(plot.data2)<-seq(1,ncol(plot.data2),1)
plot.data2$x<-rownames(plot.data2)


mydata<-melt(plot.data2,id="x")
mydata$variable<-as.numeric(mydata$variable)
mydata$x<-as.numeric(mydata$x)



library(ggplot2)
library(RColorBrewer)

colormap <- colorRampPalette(rev(brewer.pal(11,'Spectral')))(32)

scale<-0.2

p<-ggplot() +
  geom_line(data=mydata,aes(x=x,y=variable-value*scale,group=variable),colour="grey90",size=0.1)+
  geom_linerange(data=plot.data3,aes(x=x,ymin=y,ymax=y-height*scale,group=group,color=height),size=0.5)+#,alpha=0
  #geom_ribbon(data=plot.data3,aes(x=x,ymin=y,ymax=y-height*scale,group=group),fill="white")+
  
  geom_line(data=plot.data3,aes(x=x,y=y-height*scale,group=group),colour="#000000",size=0.1)+
  #geom_linerange(data=mydata,aes(x=y,ymin=variable,ymax=variable-value*scale,color=value),alpha=0.6)+
  scale_color_gradientn(colours=colormap)+
  scale_y_reverse()+
  theme(
    #panel.grid.major = element_line(colour = "grey90",size=.25,linetype ="solid" ),
    #panel.grid.minor = element_line(colour = "grey90",size=.25,linetype ="solid" ),
    plot.background=element_rect(fill="grey100",colour=NA),
    panel.background=element_rect(fill="grey100",colour=NA),
    text=element_text(size=15),
    line=element_blank(),
    axis.text=element_blank(),
    axis.title=element_blank(),
    plot.title=element_text(size=15,family="myfont"),
    plot.caption=element_text(size=10,family="myfont",hjust=0),
    legend.position="right",#c(0.85,0.2),
    #legend.justification="left",
    #legend.text.align=1,
    legend.background=element_blank()
  )
p



